import express from "express";
import session from "express-session";
import cors from "cors";
import cookieParser from "cookie-parser";
import bodyParser from "body-parser";
import mysql2 from "mysql2";
import csv from "csv-parser";
import multer from "multer";
import fs from "fs";
import path from "path";
import logger from "morgan";
import bcrypt from "bcrypt";
import Papa from "papaparse";
import passport from "passport";
import { Strategy as FacebookStrategy } from "passport-facebook";
import router from "./router/route.js";
import { Strategy as GoogleStrategy } from "passport-google-oauth20";
import { OAuthStrategy } from "passport-oauth";
import util from "util";
import { Strategy as OpenIDStrategy } from "passport-openid";
import { OAuth2Client } from "google-auth-library";
import { fileURLToPath } from "url";
import axios from "axios";
import { Strategy as LinkedInStrategy } from "passport-linkedin-oauth2";
const __filename = fileURLToPath(import.meta.url),
  __dirname = path.dirname(__filename);
console.log(__dirname);
const app = express(),
  PORT = 8080,
  pool = mysql2.createPool({
    host: "localhost",
    port: 3306,
    database: "leads",
    user: "root",
    password: "root456",
    connectionLimit: 10,
  });
pool.getConnection((err, connection) => {
  if (err) throw err;
  console.log("MySQL server running"),
    connection.query("SELECT * FROM users", (err, rows) => {
      if ((connection.release(), err)) throw err;
      console.log("Users Table Data:"), console.log(rows);
    });
});
let tables = [];
pool.query("SHOW TABLES FROM leads", (err, rows) => {
  if (err) throw err;
  (tables = rows), console.log(tables);
}),
  app.use(cors({ origin: "*" })),
  app.use(bodyParser.json()),
  app.use(cookieParser()),
  app.use(bodyParser.urlencoded({ extended: !0 })),
  app.use(logger("dev")),
  app.set("view engine", "ejs"),
  app.use(
    session({
      secret: "your-secret-key",
      saveUninitialized: !0,
      resave: !1,
      cookie: {
        name: "my-session-cookie",
        path: "/",
        expires: new Date(Date.now() + 6e4),
        maxAge: 3e5,
      },
    })
  ),
  app.use(passport.initialize()),
  app.use(passport.session()),
  app.use(express.static(path.join("D:/userportal/client/public"))),
  app.use(
    "/index.html",
    express.static("D:/userportal/client/public/index.html")
  ),
  app.use(
    "/dashboard.html",
    express.static("D:/userportal/client/public/dashboard.html")
  ),
  app.use(
    "/reset.html",
    express.static("D:/userportal/client/public/reset.html")
  ),
  app.use((req, res, next) => {
    if (req.session && req.session.user) {
      const now = Date.now(),
        lastActive = req.session.lastActive || now;
      now - lastActive > req.session.cookie.maxAge
        ? req.session.destroy((err) => {
            err && console.error("Error destroying session:", err),
              res.redirect("/?error=Session Timed Out,Login Again."),
              console.log("session has timed out");
          })
        : ((req.session.lastActive = now), next());
    } else next();
  }),
  app.get("/connect", (req, res) => {
    pool.getConnection((err, connection) => {
      err
        ? (console.log("Error connecting to server:", err), res.sendStatus(500))
        : (console.log("Connected to server"),
          connection.release(),
          res.sendStatus(200));
    });
  }),
  app.get("/abort", (req, res) => {
    const alertMessage = "User Aborted The Server!",
      alertScript = `<script>alert("${alertMessage}");<\/script>`;
    res.send(alertScript), process.exit(1);
  }),
  app.get("/login", (req, res) => {
    res.render("login.html");
  }),
  app.get("/dashboard", (req, res) => {
    if (req.session.user) {
      const timeout = 3e6,
        interval = setInterval(() => {
          req.session.user || (res.redirect("/login"), clearInterval(interval));
        }, timeout);
      res.render("dashboard.html");
    } else res.redirect("/login");
  });
const allowedFileExtensions = [".csv"],
  storage = multer.diskStorage({
    destination: path.join(__dirname, "./uploads"),
    filename: (req, file, cb) => {
      cb(null, file.originalname);
    },
  }),
  upload = multer({
    storage: storage,
    fileFilter: function (req, file, callback) {
      const fileExtension = path.extname(file.originalname).toLowerCase();
      allowedFileExtensions.includes(fileExtension)
        ? callback(null, !0)
        : callback(new Error("Only CSV file is allowed"));
    },
    limit: 20,
    headers: { "Content-Type": "text/csv" },
  });
let jsonData = [];
app.post("/upload", upload.array("csvFile"), (req, res) => {
  console.log(`Received request to ${req.url}`);
  const totalFilesCount = req.files.length + tables.length;
  if (req.files && req.files.length > 0) {
    const csvFiles = req.files;
    console.log("csvFiles was sent from client-side", csvFiles);
    const processFile = (csvFile) => (
        console.log("this is csvFile inside /upload route", csvFile),
        new Promise((resolve, reject) => {
          const results = [],
            filePath = csvFile.path,
            stream = fs.createReadStream(filePath);
          Papa.parse(stream, {
            header: !0,
            step: (result) => {
              results.push(result.data), console.log;
            },
            complete: () => {
              resolve(results);
            },
            error: (error) => {
              reject(error);
            },
          });
        })
      ),
      processFilesSequentially = async () => {
        const fileResults = [];
        for (const file of csvFiles)
          try {
            const result = await processFile(file);
            fileResults.push(result);
          } catch (error) {
            return (
              console.error("Error processing file:", error),
              void res.status(500).send("Error processing file.")
            );
          }
        res.json(fileResults);
      };
    processFilesSequentially();
  } else res.status(400).send("No file uploaded.");
}),
  app.post("/storeTableData", (req, res) => {
    const { data: data } = req.body,
      { tableName: tableName, columns: columns, data: tableData } = data;
    if (
      (console.log("Request received with data:", data),
      !tableData || !tableName || !columns)
    )
      return (
        console.log("Invalid request data"),
        res.status(400).send("Invalid request data")
      );
    createTableAndInsertData(tableName, columns, tableData, (error) => {
      error
        ? (console.error("Error storing table data:", error),
          res.status(500).json({ error: "Error storing table data" }))
        : (console.log("Table data stored successfully"),
          res.status(200).json({ message: "Table data stored successfully" }));
    });
  });
const createTableAndInsertData = (tableName, columns, data, callback) => {
    if (
      (console.log("Creating table in MySQL database:", tableName),
      !tableName || !columns || 0 === columns.length)
    )
      return (
        console.log("Invalid parameters for creating table"),
        void callback("Invalid parameters for creating table")
      );
    const sanitizedTableName = tableName.replace(/[^a-zA-Z0-9]/g, "_"),
      sanitizedColumns = columns.map((column) =>
        column.replace(/[^a-zA-Z0-9]/g, "_")
      );
    console.log("Sanitized Table Name:", sanitizedTableName),
      console.log("Sanitized Columns:", sanitizedColumns);
    const columnDefinitions = sanitizedColumns
        .map((column) => `${column} VARCHAR(255)`)
        .join(", "),
      createTableQuery = `\n    CREATE TABLE IF NOT EXISTS ${sanitizedTableName} (\n      id INT AUTO_INCREMENT PRIMARY KEY,\n      ${columnDefinitions}\n    )`;
    console.log("Create Table Query:", createTableQuery),
      pool.query(createTableQuery, (err, results) => {
        err
          ? (console.error("Error creating table:", err), callback(err))
          : (console.log(`Table ${sanitizedTableName} created successfully`),
            insertDataIntoTable(
              sanitizedTableName,
              sanitizedColumns,
              data,
              (error) => {
                callback(error || null);
              }
            ));
      });
  },
  insertDataIntoTable = (tableName, columns, data, callback) => {
    if (
      (console.log("Received data:", data),
      !tableName || !columns || !data || 0 === data.length)
    )
      return (
        console.log("Invalid parameters for inserting data into table"),
        void callback("Invalid parameters for inserting data into table")
      );
    const cleanedData = data.map((item) => {
        const cleanedItem = {};
        for (const key in item)
          if (item.hasOwnProperty(key)) {
            const cleanedKey = key.replace(/[^a-zA-Z0-9]/g, "_"),
              value = item[key];
            cleanedItem[cleanedKey] = value;
          }
        return cleanedItem;
      }),
      insertQuery = `INSERT INTO ${tableName} (${columns.join(", ")}) VALUES ?`;
    console.log("Insert Query:", insertQuery);
    const valuesArray = cleanedData.map((item) => {
      const rowValues = columns.map((column) => {
        const sanitizedColumn = column.replace(/[^a-zA-Z0-9_]/g, "_"),
          sanitizedColumnKey = sanitizedColumn.replace(/"/g, "");
        if (item.hasOwnProperty(sanitizedColumnKey)) {
          const value = item[sanitizedColumnKey];
          return null !== value ? value : "N/A";
        }
        return (
          console.log(
            `Column "${sanitizedColumnKey}" not found in item:`,
            item
          ),
          "N/A"
        );
      });
      return console.log("Row Values:", rowValues), rowValues;
    });
    console.log("Values Array:", valuesArray),
      pool.query(insertQuery, [valuesArray], (error) => {
        error
          ? (console.error("Error inserting data:", error), callback(error))
          : (console.log(`Table data stored in ${tableName} successfully`),
            callback(null));
      });
  };
function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
app.get("/tables", (req, res) => {
  pool.query("SHOW TABLES FROM leads", (err, rows) => {
    if (err)
      return (
        console.error("Error fetching table list:", err),
        void res.status(500).json({ error: "Error fetching table list" })
      );
    res.send(rows);
  });
}),
  app.post("/login", (req, res) => {
    const { email: email, user_pass: user_pass } = req.body,
      sql = "SELECT * FROM users WHERE email = ?",
      values = [email];
    pool.query(sql, values, (err, result, fields) => {
      if (err)
        console.error("Error finding user:", err),
          res.status(500).redirect("/?error=Error finding user.");
      else if (0 === result.length)
        console.log("User not found"),
          res.status(404).redirect("/?error=User not found.");
      else {
        const hashedPassword = result[0].user_pass;
        bcrypt.compare(user_pass, hashedPassword, (err, isMatch) => {
          if (err)
            console.error("Error comparing passwords:", err),
              res.status(500).redirect("/?error=Error comparing passwords.");
          else if (isMatch) {
            console.log("User logged in successfully", result),
              console.log(req.session, "line 184"),
              (req.session.user = {
                username: result[0].user_name,
                email: result[0].email,
                user_id: result[0].user_id,
              }),
              console.log("logged in credentials line 389", req.session.user),
              console.log("189 line", req.session),
              (req.session.cookie.expires = new Date(Date.now() + 6e4));
            const successMessage = "user logged in successfully";
            res.redirect(
              `/dashboard.html?success=${encodeURIComponent(successMessage)}`
            );
          } else
            console.log("Incorrect password"),
              res.status(401).redirect("/?error=Incorrect password.");
        });
      }
    });
  }),
  app.post("/register", (req, res) => {
    const {
        user_name: user_name,
        user_pass: user_pass,
        email: email,
        age: age,
        gender: gender,
      } = req.body,
      emailCheckQuery = "SELECT * FROM users WHERE email = ?",
      emailCheckValues = [email];
    if (email && !isValidEmail(email))
      return res.status(400).redirect("/?error=Invalid email.");
    pool.query(emailCheckQuery, emailCheckValues, (err, result) => {
      if (err)
        console.error("Error checking email:", err),
          res.status(500).redirect("/?error=Error checking email.");
      else if (result.length > 0)
        console.log("Email already exists"),
          res.status(409).redirect("/?emailError=Email already exists.");
      else {
        const hashedPassword = bcrypt.hashSync(user_pass, 10),
          sql =
            "INSERT INTO users (user_name, user_pass, email, age, gender) VALUES (?, ?, ?, ?, ?)",
          values = [user_name, hashedPassword, email, age, gender];
        pool.query(sql, values, (err, result) => {
          err
            ? (console.error("Error registering user:", err),
              res.status(500).redirect("/?error=Error registering user."))
            : (console.log("User registered successfully", result),
              res.redirect("/?success=User registered successfully."));
        });
      }
    });
  }),
  process.on("uncaughtException", (err) => {
    console.error("Uncaught Exception:", err), process.exit(1);
  }),
  process.on("unhandledRejection", (reason, promise) => {
    console.error("Unhandled Promise Rejection:", reason), process.exit(1);
  }),
  app.post("/reset-password", (req, res) => {
    const { email: email } = req.body,
      emailCheckQuery = "SELECT * FROM users WHERE email=?",
      emailCheckValues = [email];
    pool.query(emailCheckQuery, emailCheckValues, (err, result) => {
      if (err)
        console.error("Error checking email:", err),
          res.status(500).send("Error checking email.");
      else if (0 === result.length)
        console.log("Email not found"),
          res.status(404).send("Email not found.");
      else {
        const newPassword = generateRandomPassword(),
          hashedPassword = bcrypt.hashSync(newPassword, 10),
          updatePasswordQuery = "UPDATE users SET user_pass=? WHERE email=?",
          updatePasswordValues = [hashedPassword, email];
        pool.query(updatePasswordQuery, updatePasswordValues, (err, result) => {
          err
            ? (console.error("Error updating password:", err),
              res.status(500).send("Error updating password."))
            : (sendPasswordToUser(email, newPassword),
              res.status(200).send("Password reset successfully..."));
        });
      }
    });
  }),
  app.post("/session-timeout", (req, res) => {
    if ("Session timeout" === req.body.status) {
      const sessionTimeoutMessage =
        "Your session has expired. Please log in again.";
      res.json({ sessionTimeoutMessage: sessionTimeoutMessage });
    } else res.status(500).send("An error occurred.");
  }),
  app.get("/logout", (req, res) => {
    console.log(session, "session logged out"),
      req.session.destroy((err) => {
        if (err)
          console.error("Error destroying session:", err),
            res.status(500).send("Error destroying session.");
        else {
          if (req.user && req.user.accessToken) {
            revokeToken(req.user.accessToken);
            const { accessToken: accessToken, refreshToken: refreshToken } =
              req.user;
            linkedin.revokeTokens(accessToken, refreshToken),
              req.session.destroy(),
              console.log("revokeToken worked");
          } else console.log("User is not authenticated");
          const sessionTimeoutMessage =
            "Your session has expired or logged out. Please log in again.";
          res.json({ message: sessionTimeoutMessage });
        }
      });
  });
const oauth2Client = new OAuth2Client(
  "1044384300379-p2stncd95po7p4ikoethg8uhbh80oc6j.apps.googleusercontent.com",
  "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",
  "http://localhost:8080/auth/google/callback"
);
async function revokeToken(accessToken) {
  try {
    await oauth2Client.revokeToken(accessToken), console.log("Token revoked");
  } catch (err) {
    console.error("Error revoking token:", err);
  }
}
async function checkToken(accessToken) {
  try {
    oauth2Client.setCredentials({ access_token: accessToken });
    const res = await oauth2Client.request({
      url: "https://www.googleapis.com/oauth2/v1/userinfo",
    });
    console.log(res.data);
  } catch (err) {
    err.response &&
    err.response.data &&
    "invalid_grant" === err.response.data.error
      ? console.log("Token is invalid")
      : console.error("Error checking token:", err);
  }
}
function DisplayTableData(tableName) {
  console.log("DisplayTableData function is working"),
    axios
      .get(`/tables/${tableName}`)
      .then((response) => {
        displayTableWindow(response.data, tableName),
          console.log("response sent to displayTableWindow", response.data),
          console.log(
            "type of data I am sending to displayTableWindow is",
            typeof response.data
          );
      })
      .catch((error) => {
        console.error(error);
      }),
    console.log("axios has sent a request to get the tables with tableName");
}
function displayTableWindow(data, tableName) {
  const windowTitle = document.getElementById("windowTitle");
  windowTitle.textContent = tableName;
}
app.get("/", (req, res) => {
  res.sendFile("D:/userportal/client/public/index.html");
}),
  app.get("/user-data", (req, res) => {
    if ((console.log("get user-data get initiated"), req.session.user)) {
      const {
        username: username,
        email: email,
        user_id: user_id,
      } = req.session.user;
      console.log("line 496 request sent to Front-end", req.session.user),
        res.json({ username: username, email: email, user_id: user_id }),
        console.log(
          "username , email, user_id sent to front-end",
          username,
          email,
          user_id
        );
    } else res.status(401).json({ error: "User not authenticated" });
  }),
  app.get("/tables/:tableName", (req, res) => {
    console.log("request coming from front-end for getting tables from DB");
    const table = req.params.tableName;
    console.log("Getting request from Front-end for table:", table),
      pool.query(`SELECT * FROM ${table}`, (err, results) => {
        err
          ? (console.error("Error executing SQL query:", err),
            res.status(500).json({ error: "Internal Server Error" }))
          : res.status(200).json(results);
      });
  }),
  app.delete("/tables/:tableName", (req, res) => {
    const tableName = req.params.tableName;
    if (!tableName)
      return res.status(400).json({ error: "Invalid table name" });
    const dropTableQuery = `DROP TABLE IF EXISTS ${tableName}`;
    pool.query(dropTableQuery, (err, result) => {
      err
        ? (console.error("Error dropping table:", err),
          res.status(500).json({ error: "Error dropping table" }))
        : (console.log(`Table ${tableName} dropped successfully`),
          res
            .status(200)
            .json({ message: `Table ${tableName} dropped successfully` }));
    });
  }),
  app.patch("/updateTableCell/:tableName/:rowId", async (req, res) => {
    const { tableName: tableName, rowId: rowId } = req.params,
      { updatedData: updatedData, oldData: oldData } = req.body;
    try {
      if (!(tableName && rowId && updatedData && oldData))
        return res.status(400).json({ error: "Invalid request data" });
      const checkTableQuery = `SHOW TABLES LIKE '${tableName}'`,
        tableExists = await checkTableExists(checkTableQuery);
      if (!tableExists)
        return res.status(404).json({ error: `Table ${tableName} not found` });
      const updateQuery = `UPDATE ${tableName} SET ${Object.keys(updatedData)
          .map((column) => `${column} = ?`)
          .join(", ")} WHERE id = ?`,
        values = [...Object.values(updatedData), rowId];
      await executeQuery(updateQuery, values),
        res.json({ message: "Table cell updated successfully" });
    } catch (err) {
      console.error("Error updating table cell:", err),
        res.status(500).json({ error: "Error updating table cell" });
    }
  }),
  app.post("/deleteSelectedTables", (req, res) => {
    let tableNames,
      sql = `DROP TABLE ${req.body.tableNames.join(", ")}`;
    pool.query(sql, (err, result) => {
      err
        ? (console.error(err), res.status(500).send("Error deleting tables"))
        : (console.log(result),
          res.status(200).send("Tables deleted successfully"));
    });
  }),
  app.use(
    session({ secret: "your-secret-key", resave: !0, saveUninitialized: !0 })
  ),
  app.use(passport.initialize()),
  app.use(passport.session()),
  app.use(passport.authenticate("linkedin", { callbackURL: "/login" }));
const queryAsync = util.promisify(pool.query).bind(pool);
function checkTableExists(query) {
  return new Promise((resolve, reject) => {
    pool.query(query, (err, result) => {
      err ? reject(err) : resolve(result.length > 0);
    });
  });
}
function executeQuery(query, values) {
  return new Promise((resolve, reject) => {
    pool.query(query, values, (err, result) => {
      err ? reject(err) : resolve(result);
    });
  });
}
function ensureAuthenticated(req, res, next) {
  if (req.isAuthenticated()) return next();
  res.redirect("/login");
}
passport.use(
  new FacebookStrategy(
    {
      clientID: "799022472012843",
      clientSecret: "598352d12e1c0f08c5cea60070e91b10",
      callbackURL: "http://localhost:8080/oauth2/redirect/facebook",
      enableProof: !0,
    },
    async function (accessToken, refreshToken, profile, cb) {
      try {
        await queryAsync("BEGIN");
        const [cred] = await queryAsync(
          "SELECT * FROM users WHERE facebook_Id = ?",
          [profile.id]
        );
        let user;
        if ((console.log(profile), cred))
          await queryAsync(
            "UPDATE users SET access_token = ?, refresh_token = ? WHERE user_id = ?",
            [accessToken, refreshToken, cred.user_id]
          ),
            ([user] = await queryAsync(
              "SELECT * FROM users WHERE user_id = ?",
              [cred.user_id]
            ));
        else {
          const result = await queryAsync(
              "INSERT INTO users (user_name,  facebook_Id, access_token, refresh_token) VALUES (?, ?,  ?, ?)",
              [profile.name, profile.id, accessToken, refreshToken]
            ),
            id = result.insertId;
          let email;
          profile.emails &&
            profile.emails.length > 0 &&
            (email = profile.emails[0].value),
            (user = {
              id: id.toString(),
              user_name: profile.name,
              facebook_Id: profile.id,
              access_token: accessToken,
              refresh_token: refreshToken,
            });
        }
        return await queryAsync("COMMIT"), console.log(user), cb(null, user);
      } catch (err) {
        return await queryAsync("ROLLBACK"), cb(err);
      }
    }
  )
),
  app.get(
    "/auth/facebook",
    passport.authenticate("facebook", {
      authType: "reauthenticate",
      scope: ["email"],
    })
  ),
  app.get(
    "/oauth2/redirect/facebook",
    passport.authenticate("facebook", { failureRedirect: "/login" }),
    function (req, res) {
      res.redirect("http://localhost:8080/dashboard.html");
    }
  ),
  passport.serializeUser((user, done) => {
    done(null, user);
  }),
  passport.deserializeUser((user, done) => {
    done(null, user);
  }),
  app.get("/facebook-user", (req, res) => {
    if (
      (console.log("route facebook-user has been executed"),
      req.isAuthenticated())
    ) {
      const user = req.user,
        findUserIdQuery = "SELECT user_id FROM users WHERE facebook_Id = ?";
      pool.query(findUserIdQuery, [user.facebook_Id], (err, result) => {
        if (err)
          return (
            console.error("Error querying the database:", err),
            res.status(500).json({ error: "Error querying the database" })
          );
        if (0 === result.length)
          return (
            console.log("User not found in the database"),
            res.status(404).json({ error: "User not found" })
          );
        const user_id = result[0].user_id,
          userData = {
            email: user.email,
            username: user.user_name,
            user_id: user_id,
          };
        console.log("this is facebook user data going to front-end", userData),
          res.json(userData),
          console.log("user has been authenticated", user),
          console.log("userData has been authenticated", userData);
      });
    } else res.status(401).json({ error: "User not authenticated" });
  }),
  passport.authenticate("google"),
  passport.use(
    new GoogleStrategy(
      {
        clientID:
          "1044384300379-p2stncd95po7p4ikoethg8uhbh80oc6j.apps.googleusercontent.com",
        clientSecret: "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",
        callbackURL: "http://localhost:8080/auth/google/callback",
        prompt: "login",
      },
      async (accessToken, refreshToken, profile, done) => {
        try {
          if (!profile || !profile.id)
            return done(new Error("Invalid profile data"));
          console.log(profile);
          const { id: id, displayName: displayName, emails: emails } = profile,
            email = emails[0].value,
            findUserQuery = "SELECT * FROM users WHERE google_Id = ?";
          try {
            const result = await executeQuery(findUserQuery, [id]);
            if (0 !== result.length) {
              const alertMessage = "User is a duplicate entry.";
              return (
                console.log(alertMessage),
                done(null, {
                  id: id,
                  email: email,
                  displayName: displayName,
                  alertMessage: alertMessage,
                })
              );
            }
            {
              const insertUserQuery =
                  "INSERT INTO users (google_Id, email, user_name) VALUES (?, ?, ?)",
                values = [id, email, displayName];
              try {
                return (
                  await executeQuery(insertUserQuery, values),
                  console.log("User data stored in the database:", email),
                  console.log("google_Id stored in the database:", id),
                  console.log("Username in the database:", displayName),
                  done(null, { id: id, email: email, displayName: displayName })
                );
              } catch (insertError) {
                return (
                  console.error(
                    "Error storing user in the database:",
                    insertError
                  ),
                  done(insertError)
                );
              }
            }
          } catch (queryError) {
            return (
              console.error("Error querying the database:", queryError),
              done(queryError)
            );
          }
        } catch (error) {
          return console.error("Error in verification:", error), done(error);
        }
      }
    )
  ),
  passport.serializeUser((user, done) => {
    done(null, user);
  }),
  passport.deserializeUser((user, done) => {
    done(null, user);
  }),
  app.get(
    "/auth/google",
    passport.authenticate("google", {
      authType: "reauthenticate",
      scope: ["profile", "email"],
    })
  ),
  app.get(
    "/auth/google/callback",
    passport.authenticate("google", { failureRedirect: "/login" }),
    (req, res) => {
      res.redirect(
        `/dashboard.html?user=${encodeURIComponent(JSON.stringify(req.user))}`
      );
    }
  ),
  app.get(
    "/oauth2/redirect/google",
    passport.authenticate("google", {
      successRedirect:
        "/dashboard.html?user=${encodeURIComponent(JSON.stringify(req.user))}",
      failureRedirect: "/login",
    })
  ),
  app.get("/google-user", (req, res) => {
    if (
      (console.log("route google-user has been executed"),
      req.isAuthenticated())
    ) {
      const user = req.user,
        findUserIdQuery = "SELECT user_id FROM users WHERE google_Id = ?";
      pool.query(findUserIdQuery, [user.id], (err, result) => {
        if (err)
          return (
            console.error("Error querying the database:", err),
            res.status(500).json({ error: "Error querying the database" })
          );
        if (0 === result.length)
          return (
            console.log("User not found in the database"),
            res.status(404).json({ error: "User not found" })
          );
        const user_id = result[0].user_id,
          userData = {
            email: user.email,
            username: user.displayName,
            user_id: user_id,
          };
        res.json(userData),
          console.log("user has been authenticated", user),
          console.log("userData has been authenticated", userData);
      });
    } else res.status(401).json({ error: "User not authenticated" });
  }),
  router.get("/login/federated/google", passport.authenticate("google")),
  passport.serializeUser((user, done) => {
    done(null, user.id);
  }),
  passport.deserializeUser((id, done) => {
    const findUserQuery = "SELECT * FROM users WHERE id = ?";
    pool.query(findUserQuery, [id], (err, result) => {
      if (err)
        return console.error("Error querying the database:", err), done(err);
      if (0 === result.length) return done(null, !1);
      const user = result[0];
      return done(null, user);
    });
  }),
  app.get("/profile", (req, res) => {
    if (req.isAuthenticated()) {
      const user = req.user;
      res.render("profile", { user: user });
    } else res.redirect("/");
  }),
  passport.use(
    "linkedin",
    new LinkedInStrategy(
      {
        clientID: "86p5hp5w3t7zsx",
        clientSecret: "MxkM1Y7zGQFGvGdJ",
        requestTokenURL: "https://api.linkedin.com/oauth/request_token",
        accessTokenURL: "https://api.linkedin.com/oauth/access_token",
        userAuthorizationURL: "https://api.linkedin.com/oauth/authorize",
        consumerKey: "86p5hp5w3t7zsx",
        consumerSecret: "MxkM1Y7zGQFGvGdJ",
        callbackURL: "http://localhost:8080/auth/linkedin/callback",
        scope: ["w_member_social", "openid", "profile", "email"],
      },
      async (accessToken, refreshToken, profile, done) => {
        process.nextTick(() => {
          try {
            if (!profile || !profile.id)
              throw new Error("Invalid profile data");
            console.log(profile);
            const {
              id: id,
              displayName: displayName,
              emails: emails,
            } = profile;
            pool.connect();
            const findUserQuery = "SELECT * FROM users WHERE linkedin_Id = ?",
              result = connection.query(findUserQuery, [id]);
            if (0 === result.length) {
              const insertUserQuery =
                  "INSERT INTO users (linkedin_Id, user_name) VALUES (?, ?)",
                values = [id, displayName];
              return (
                pool.query(insertUserQuery, values),
                console.log("User data stored in the database:", displayName),
                console.log("linkedin_Id stored in the database:", id),
                done(null, { id: id, displayName: displayName })
              );
            }
            {
              const alertMessage = "User is a duplicate entry.";
              return (
                console.log(alertMessage),
                done(null, {
                  id: id,
                  displayName: displayName,
                  alertMessage: alertMessage,
                })
              );
            }
          } catch (error) {
            return console.error("Error in verification:", error), done(error);
          }
        });
      }
    )
  ),
  passport.serializeUser((user, done) => {
    done(null, user);
  }),
  passport.deserializeUser((obj, done) => {
    done(null, obj);
  }),
  app.get(
    "/auth/linkedin",
    passport.authenticate("linkedin", { state: "SOME STATE" }),
    (req, res) => {}
  ),
  app.get(
    "/auth/linkedin/callback",
    passport.authenticate("linkedin", { failureRedirect: "/" }),
    (req, res) => {
      res.redirect("/");
    }
  ),
  app.get("/account", ensureAuthenticated, function (req, res) {
    res.render("account", { user: req.user });
  }),
  app.listen(8080, () => {
    console.log("Server listening on port 8080");
  });
